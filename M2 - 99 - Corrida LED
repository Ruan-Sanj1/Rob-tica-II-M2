/* ____                     _      ______ _____    _____
  / __ \                   | |    |  ____|  __ \  |  __ \               
 | |  | |_ __   ___ _ __   | |    | |__  | |  | | | |__) |__ _  ___ ___ 
 | |  | | '_ \ / _ \ '_ \  | |    |  __| | |  | | |  _  // _` |/ __/ _ \
 | |__| | |_) |  __/ | | | | |____| |____| |__| | | | \ \ (_| | (_|  __/
  \____/| .__/ \___|_| |_| |______|______|_____/  |_|  \_\__,_|\___\___|
        | |                                                             
        |_|          
Open LED Race, uma corrida de carro minimalista para fitas LED!
Este é um programa gratuito e você pode distribuir e/ou modificá-lo pelos
termos GNU Gerneral Public License (Licença Pública Geral), publicado pela
Free Software Foundation (Fundação de Software Gratuitos), e
também pela versão 3 da Licença, ou qualquer versão recente.
por gbarbarov@singulardevices.com para Arduino day Seville 2019
https://www.hackster.io/gbarbarov/open-led-race-a0331a
https://twitter.com/openledrace

Próximos melhoramentos em:
https://gitlab.com/open-led-race
https://openledrace.net/open-software/
Traduzido e adaptado*/

#include “preambulo.h”
void setup() {
pista.begin();
pista.setBrightness(BRILHO_MAX);
pista.clear();
pista.show();
pinMode(PIN_P1, INPUT_PULLUP);
pinMode(PIN_P2, INPUT_PULLUP);
/* Inicia com o valor de gravidade nula para todos os LEDs (127). O mapa varia de 0 a 255.
mapa_gravidade[i] = 127 (Aceleração da gravidade nula - Superfície plana)
mapa_gravidade[i] > 127 (Aceleração da gravidade positiva - Descendo a rampa)
mapa_gravidade[i] < 127 (Aceleração da gravidade negativa - Subindo a rampa) */
for (int i = 0; i < N_LEDs; i++) {
mapa_gravidade[i] = 127;
}
iniciar_corrida();
}



------------------------------------------PREAMBULO.H------------------------------------------
#include <Adafruit_NeoPixel.h>
#define maxLEDs 300
int N_LEDs = MAX_LEDs;
#define BRILHO_MAX 60
#define PIN_LED 
#define PIN_P1 
#define PIN_P2 
#define PIN_AUDIO 

/* Define as cores dos players. */
// 1 - Vermelho
// 2 - Verde
// 3 - Azul
// 4 - Amarelo (Vermelho + Verde)
// 5 - Ciano (Verde + Azul)
// 6 - Magenta (Vermelho + Azul)
int Cor_P1 = ; 
int Cor_P2 = ; 

byte mapa_gravidade[MAX_LEDs];

float velocidade1 = 0;
float velocidade2 = 0; 
float dist1 = ;
float dist2 = ;
byte n_voltas_P1 = 0;
byte n_voltas_P2 = 0;
byte n_max_voltas = 5;

float ACELERACAO = 0.2;
float kf = 0.015;
float kg = 0.003;
byte flag_botao1 = 0;
byte flag_botao2 = 0; 
int controle_bip; 


byte ordem_desenho = 0;
unsigned long tempoAtual = 0;
unsigned long ultimaAlteracao = 0;
int tempo_delay = 5; 
Adafruit_NeoPixel pista(MAX_LEDs, PIN_LED);





------------------------------------------INICIARCORRIDA.INO------------------------------------------
void iniciar_corrida() {
while (digitalRead(PIN_P1) == 1) {}
if (digitalRead(PIN_P2) == 0) {
/* rampa(Altura, Inicio_Subida, Topo, Final_Descida) */
rampa();
/* Cada unidade de medida representa um LED*/
}
}





------------------------------------------CRIARRAMPA.INO------------------------------------------
void rampa(byte H, byte a
, byte b, byte c) {
for (int i = 0; i < (b - a); i++) {
mapa_gravidade[a + i] = 127 - i * ((float)H / (b - a));
}
mapa_gravidade[b] = 127;
for (int i = 0; i < (c - b); i++) {
mapa_gravidade[b + i + 1] = 127 + H - i * ((float)H / (c - b));
}
}





--------------------------------------Parte 2 -INICIARCORRIDA.INO ------------------------------------------
pista.setPixelColor(12, pista.Color(255, 0, 0));
pista.setPixelColor(11, pista.Color(255, 0, 0));
pista.show();
tone(PIN_AUDIO, 400);
delay(2000);
noTone(PIN_AUDIO);
pista.setPixelColor(12, pista.Color(0, 0, 0));
pista.setPixelColor(11, pista.Color(0, 0, 0));
pista.setPixelColor(10, pista.Color(255, 255, 0));
pista.setPixelColor(9, pista.Color(255, 255, 0));
pista.show();
tone(PIN_AUDIO, 600);
delay(2000);
noTone(PIN_AUDIO);
pista.setPixelColor(9, pista.Color(0, 0, 0));
pista.setPixelColor(10, pista.Color(0, 0, 0));
pista.setPixelColor(8, pista.Color(0, 255, 0));
pista.setPixelColor(7, pista.Color(0, 255, 0));
pista.show();
tone(PIN_AUDIO, 1200);
delay(2000);
noTone(PIN_AUDIO);
pista.setPixelColor(8, pista.Color(0, 0, 0));
pista.setPixelColor(7, pista.Color(0, 0, 0));
pista.show();
}






-------------------------------------------LOOP----------------------------------------
void loop() {
tempoAtual = millis();

if (tempoAtual - ultimaAlteracao >= 200) {
if (ordem_desenho == 0) {
ordem_desenho = 1;
ultimaAlteracao = tempoAtual;
} else {
ordem_desenho = 0;
ultimaAlteracao = tempoAtual;
}
}

if (ordem_desenho == 0) {
desenhar_carro1();
desenhar_carro2();
} else {
desenhar_carro2();
desenhar_carro1();
}
pista.show();
}





------------------------------------------DESENHAR_CARRO1.INO------------------------------------------
void desenhar_carro1(void) {
switch (Cor_P1) {
case 1: /* Vermelho. */
for (int i = 0; i <= n_voltas_P1; i++) {
pista.setPixelColor(((word)dist1 % N_LEDs) + i, pista.Color(255, 0, 0));
}
break;

case 2: /* Verde. */
for (int i = 0; i <= n_voltas_P1; i++) {
pista.setPixelColor(((word)dist1 % N_LEDs) + i, pista.Color(0, 255, 0));
}
break;

case 3: /* Azul . */
for (int i = 0; i <= n_voltas_P1; i++) {
pista.setPixelColor(((word)dist1 % N_LEDs) + i, pista.Color(0, 0,255));
}
break;

case 4:/* Amarelo. */
for (int i = 0; i <= n_voltas_P1; i++) {
pista.setPixelColor(((word)dist1 % N_LEDs) + i, pista.Color(255, 255,0)); 
}
break;

case 5:/* Ciano. */
for (int i = 0; i <= n_voltas_P1; i++) {
pista.setPixelColor(((word)dist1 % N_LEDs) + i, pista.Color(0, 255,255));
}
break;

case 6:/* Magenta. */
for (int i = 0; i <= n_voltas_P1; i++) {
pista.setPixelColor(((word)dist1 % N_LEDs) + i, pista.Color(255,0, 255));
}
break;

}
}





-------------------------------------LOOP - Parte 2------------------------------------
for (int i = 0; i < N_LEDs; i++) {
if ((127 - mapa_gravidade[i]) != 0) {
pista.setPixelColor(i, pista.Color(0, 0, 255));
} else {
pista.setPixelColor(i, pista.Color(0, 0, 0));
}
}

/********** Controle do movimento do Player 1 **********/
/*flag_botao1 == 0 (botão está pressionado)
flag_botao1 == 1 (botão está solto) */
if ((flag_botao1 == 0) && (digitalRead(PIN_P1) == 1)) { 
flag_botao1 = 1; 
}

if ((flag_botao1 == 1) && (digitalRead(PIN_P1) == 0)) { 
flag_botao1 = 0;
velocidade1 += ACELERACAO;
}

if ((mapa_gravidade[(word)dist1 % N_LEDs]) < 127) {
  velocidade1 -= kg * (127 - (mapa_gravidade[(word)dist1 % N_LEDs]));
}
if ((mapa_gravidade[(word)dist1 % N_LEDs]) > 127) {
  velocidade1 += kg * ((mapa_gravidade[(word)dist1 % N_LEDs]) -127);
}
velocidade1 -= velocidade1 * kf;





/**********Controle do movimento do Player 2**********/
/*flag_botao2 == 0 (botão está pressionado)
flag_botao2 == 1 (botão está solto) */
if ((flag_botao2 == 0) && (digitalRead(PIN_P2) == 1)) { 
flag_botao2 = 1;
}
if ((flag_botao2 == 1) && (digitalRead(PIN_P2) == 0)) {
flag_botao2 = 0;
velocidade2 += ACELERACAO;
}

if ((mapa_gravidade[(word)dist2 % N_LEDs]) < 127) {
velocidade2 -= kg * (127 - (mapa_gravidade[(word)dist2 % N_
LEDs]));
}

if ((mapa_gravidade[(word)dist2 % N_LEDs]) > 127) {
velocidade2 += kg * ((mapa_gravidade[(word)dist2 % N_LEDs]) -
127);
}
velocidade2 -= velocidade2 * kf;

dist1 += velocidade1;
dist2 += velocidade2;

if (dist1 > N_LEDs * n_voltas_P1) {
n_voltas_P1++;
tone(PIN_AUDIO, 700, 50);
controle_bip = 3;
}

if (dist2 > N_LEDs * n_voltas_P2) {
n_voltas_P2++;
tone(PIN_AUDIO, 200, 50);
controle_bip = 3;
}

if (controle_bip == 0) {
noTone(PIN_AUDIO);
} else {
controle_bip -= 1;
}


/***** Verificar se a corrida acabou para o P1 *****/ 
  if (n_voltas_P1 > n_max_voltas) { 
    for (int i = 0; i < N_LEDs; i++) { 
      switch (Cor_P1) { 
        case 1:  //Vermelho 
          pista.setPixelColor(i, pista.Color(255, 0, 0)); 
          break; 
        case 2:  //Verde 
          pista.setPixelColor(i, pista.Color(0, 255, 0)); 
          break; 
        case 3:  //Azul 
          pista.setPixelColor(i, pista.Color(0, 0, 255)); 
          break; 
        case 4:  //Amarelo 
          pista.setPixelColor(i, pista.Color(255, 255, 0)); 
          break; 
        case 5:  //Ciano 
          pista.setPixelColor(i, pista.Color(0, 255, 255)); 
          break; 
         case 6:  //Magenta 
          pista.setPixelColor(i, pista.Color(255, 0, 255)); 
          break; 
      } 
    } 

    pista.show();
    musica_vitoria(); 
    pista.clear(); 
    pista.show();       

    n_voltas_P1 = 0; 
    n_voltas_P2 = 0; 
    dist1 = 0; 
    dist2 = 0; 
    velocidade1 = 0; 
    velocidade2 = 0; 

    for (int i = 0; i < N_LEDs; i++) { 
      mapa_gravidade[i] = 127; 
    } 

    iniciar_corrida(); 
  }

/***** Verificar se a corrida acabou para o P2 *****/ 
  if (n_voltas_P2 > n_max_voltas) { 
    for (int i = 0; i < N_LEDs; i++) { 
      switch (Cor_P2) { 
        case 1:  //Vermelho 
          pista.setPixelColor(i, pista.Color(255, 0, 0)); 
          break; 
        case 2:  //Verde 
          pista.setPixelColor(i, pista.Color(0, 255, 0)); 
          break; 
         case 3:  //Azul 
          pista.setPixelColor(i, pista.Color(0, 0, 255)); 
          break; 
        case 4:  //Amarelo 
          pista.setPixelColor(i, pista.Color(255, 255, 0)); 
          break; 
        case 5:  //Ciano 
          pista.setPixelColor(i, pista.Color(0, 255, 255)); 
          break; 
        case 6:  //Magenta 
          pista.setPixelColor(i, pista.Color(255, 0, 255)); 
          break; 
      } 
    } 

    pista.show();  
    musica_vitoria(); 
    pista.clear(); 
    pista.show();
    n_voltas_P1 = 0; 
    n_voltas_P2 = 0; 
    dist1 = 0; 
    dist2 = 0; 
    velocidade1 = 0; 
    velocidade2 = 0; 
    for (int i = 0; i < N_LEDs; i++) { 
      mapa_gravidade[i] = 127; 
    } 
    iniciar_corrida(); 
  }
  
  delay(tempo_delay); 
}





------------------------------------------MUSICA_VITORIA.INO------------------------------------------
void musica_vitoria() { 
  int win_musica[] = { 
    2093, 2637, 3136, 3520, 
    3520, 3951, 4186, 4186, 
    3951, 3520, 3136, 2637, 
    2349, 2093, 2349, 2637, 
    3136 
  }; 

  int msize = sizeof(win_musica) / sizeof(int);  

  for (int note = 0; note < msize; note++) {  
    tone(PIN_AUDIO, win_musica[note], 200);  
    delay(230);  
    noTone(PIN_AUDIO);  
  } 
}
